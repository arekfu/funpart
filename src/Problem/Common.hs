{-# LANGUAGE GeneralizedNewtypeDeriving, FlexibleContexts #-}
module Problem.Common
( Problem
, runHistory
, runProblem
) where

import Control.Monad.RWS.Strict
import System.Random (mkStdGen, StdGen)
import Data.List (foldl')

import qualified SimSetup
import Particle
import Track hiding (secondaries)
import Source
import Score

newtype Problem a = Problem { unProblem :: RWS SimSetup.SimSetup [Track] StdGen a }
                    deriving (Monad, MonadReader SimSetup.SimSetup, MonadState StdGen, MonadWriter [Track], Applicative, Functor)

runProblem :: Problem () -> SimSetup.SimSetup -> [Score]
runProblem problem setup = scores
                           where seed = SimSetup.initialSeed setup
                                 initialGen = mkStdGen seed
                                 problem' = unProblem problem
                                 tracks = snd $ evalRWS problem' setup initialGen
                                 emptyScores = SimSetup.scores setup
                                 scores = foldl' updateAllByTrack emptyScores tracks

-- | Take one transport step.


-- | Solve one transport history.
solve :: (MonadState StdGen m, MonadReader SimSetup.SimSetup m, MonadWriter [Track] m) =>
         Particle -> m [Particle]
solve = undefined

-- | Completely solve one transport history.
solveAll :: (MonadReader SimSetup.SimSetup m, MonadState StdGen m, MonadWriter [Track] m)
         => [Particle]  -- ^ The particles to transport
         -> m ()  -- ^ The tracks generated by the particles
solveAll [] = return ()
solveAll (p:ps) = do secondaries <- solve p
                     let ps' = secondaries ++ ps
                     solveAll ps'

runHistory :: (MonadReader SimSetup.SimSetup m, MonadState StdGen m, MonadWriter [Track] m) => m ()
runHistory = do
    (SimSetup.SimSetup _ _ _ _ source _) <- ask
    particles <- sampleParticles source
    solveAll particles
